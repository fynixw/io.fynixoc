+++
date = '2026-02-28T18:00:00+08:00'
draft = false
title = 'AI时代软件工程：起点与终点'
categories = ['Agentic Coding']
tags = ['AI', '软件工程', 'LLM', '工程实践']
featuredImage = "/images/ai-software-engineering-1.jpg"
images = ["/images/ai-software-engineering-1.jpg", "/images/ai-software-engineering-2.jpg", "/images/ai-software-engineering-3.jpg"]
+++

> 随着大语言模型在编程领域攻城拔寨，当AI能够将需求翻译为代码时，软件开发活动是否迎来了宿命的终点？软件产业从业者应该何去何从？或许这个问题的答案将深刻改变软件工程的实践范式。

## 一个有趣的事实

大语言模型的能力涌现，始于机器翻译。

2017年Transformer架构论文《Attention Is All You Need》发表时，没有人能预料到它在翻译任务上的突破会演变成通用智能的火花。从Seq2Seq到GPT-4/Claude，从翻译词组到理解世界——AI用十年时间证明了：**翻译能力的边界，远比人类想象的更辽阔。**

这带来一个有趣的追问：如果软件工程本质上也是一种"翻译"呢？

## 软件工程：一种翻译过程

让我们回顾传统软件开发活动的起点和终点——从需求规格到可运行软件，重新审视这一整个软件开发流程，这个过程与翻译何其相似：

- **输入**：原始的需求开发请求
- **架构设计**：收集开发请求，澄清需求内涵，察觉用户动机，做出架构设计与权衡的决策，产出完整、内聚、自洽的需求规格说明书（SRS）
- **交互设计**：根据需求规格说明书里的功能需求部分，设计软件和用户的交互路径，产出UX/UI设计稿
- **编码开发**：根据需求规格说明书，完成编码设计，产出可以部署运行、功能可以被验证的静态代码
- **系统部署**：根据需求规格说明书里的性能约束，选择合适的部署架构，将编码开发阶段产出的静态代码部署为可以稳定运行、可以持续运行的软件系统
- **输出**：一套在"可靠、安全、成本、性能、运行"等 多维度匹配当前业务价值的软件系统

这些步骤中，架构设计、交互设计、编码开发以及系统部署等环节，本质上都是**信息**在不同形态之间的转换。

传统软件工程的困境在于：这个"翻译"过程太长了。需求模糊、变更频繁、人员流动……每一个环节都在累积"翻译损耗"。于是传统软件工程的一半精力都花在**变更管理**上：需求评审、版本控制、发布审核、配置管理。

## 容器：打破验证僵局

**容器已成为事实上的部署平台**让局面发生了一些变化。

这意味着什么？意味着"可部署"不再是一个模糊的状态——它可以通过`docker run`来**精确验证**。软件运行的验证也分层了：

- **黑盒验证**：功能响应测试
- **灰盒验证**：可观测指标（日志、Metrics、Trace）

当验证变得可量化，AI生成的软件就有了"可验收"的可能。

## Vibe Coding：改变了软件开发的重心

核心论点：Vibe Coding将工程师的宝贵精力从编码开发的细节中解放出来，重心变成更加**精确**地表达"做成什么样"的目标。

## 信心：AI生成的软件投产的最大障碍

但真正阻碍AI生成的软件投产的，不是技术能力，而是**信心**。

LLM的不确定性让产出不可预测。今天生成的代码能跑，明天同样的Prompt可能产出略有不同的结果。这种"不可预测性"在传统软件工程看来是致命的——我们习惯了确定性：同一个需求、同样的实现、一样的行为。

AI不会成为赛博永动机。它有局限，它的局限就在于**缺乏可运营信心**。

但如果我们换一个思路呢？

## 新的范式：从业者的角色重塑

如果AI负责"翻译"，人负责"把关"，会怎样？

**起点**：一份完整、内聚、自洽的需求规格说明书（由需求工程师撰写）
**终点**：软件验收通过（由验收工程师判定）

中间过程交给AI。架构师和开发者的职责不再是写代码，而是：
1. **引导式沟通**：为开发过程注入清晰性
2. **架构分析**：将需求转化为可执行的技术方案
3. **软件验证**：验证AI生成的软件是否满足需求，反思需求规格说明中的不合理，以及验收标准中的不明确

输出的仍是一份规格说明书——但这次，它是给AI的**精确指令**。

## 结语

AI不会取代软件工程师，正如汽车没有取代马车夫——但它会重新定义"赶路"这件事。

未来的软件工程从业者，只需要两种角色：
- **需求工程师**：把想法写成精确的规格
- **验收工程师**：判定AI的产出是否满足规格

软件开发活动的终点，从来都是**验收通过**。只是这一次，我们可以把中间的过程，放心地交给AI去"翻译"。

而开发者，终于可以回到最本质的问题：**我们想要什么。**
